#!/usr/bin/env python
# Author:   Ondrej Platek,2013, code is without any warranty!
# Created:  14:29:00 07/03/2013
# Modified: 14:29:00 07/03/2013

import argparse
import subprocess
import re
from numpy import mean


def getLog(path):
    try:
        rt = subprocess.check_output(['grep', '-r', 'real-time factor', path])
        wer = subprocess.check_output(['grep', '-r', '%WER', path])
        ser = subprocess.check_output(['grep', '-r', '%SER', path])
        return (rt, wer, ser)
    except subprocess.CalledProcessError as err:
        print err


def readLogs(rtpath, werpath):
    # let the exception be seen
    rt = open(rtpath).read()
    wer = open(werpath).read()
    ser = wer  # ATTENTION in our setting the same log
    return (rt, wer, ser)


def extractResults(rt, wer, ser):
    rt = rt.splitlines()
    wer = wer.splitlines()
    ser = ser.splitlines()
    # expp follow convention name the exp directories:
    # exp/ expBlabalabla/ exp_asdfasdf/  ...
    expp = re.compile(r'exp.*?/(.*?)/')
    rtp = re.compile(r'([0-9\.]+)$')
    werp = re.compile(r'%WER ([0-9\.]+)')
    serp = re.compile(r'%SER ([0-9\.]+)')
    itp = re.compile(r'wer_([0-9][0-9]?):%[SW]ER')

    # for l in ser:  # debugging
    #     print l
    #     print expp.search(l).group(1)
    try:
        rts = [(expp.search(l).group(1), rtp.search(l).group(1)) for l in rt]
    except:
        print rt
        raise
    try:
        wers = [(expp.search(l).group(1), werp.search(l).group(1), itp.search(l).group(1))
                for l in wer]
    except:
        print wer
        raise
    try:
        sers = [(expp.search(l).group(1), serp.search(l).group(1), itp.search(l).group(1))
                for l in ser]
    except:
        print ser
        raise

    exp_names = list(
        set([n for (n, _) in rts] + [n for (n, _, _) in wers]))
    results = {}
    for e in exp_names:
        w = [(float(wr), int(it)) for (exp, wr, it) in wers if exp == e]
        s = [(float(sr), int(it)) for (exp, sr, it) in sers if exp == e]
        r = [float(r_) for (exp, r_) in rts if exp == e]
        w.sort()
        s.sort()
        r.sort()
        results[e] = (w, s, r)
    return results


class Table(object):
    def __init__(self, data=[], colnames=[]):
        self.data = data
        self.colnames = colnames
        self.colSep = '\t'
        self.lineSep = '\n'

    def data2str(self):
        strdata = []
        for r in self.data:
            strdata.append([str(c) for c in r])
        return strdata

    def __str__(self):
        sd = self.data2str()
        colwidth = [len(c) for c in self.colnames]
        for j in range(len(colwidth)):
            for r in sd:
                colwidth[j] = max(colwidth[j], len(r[j]))

        gaps = [m - len(c) for (m, c) in zip(colwidth, self.colnames)]
        rows = [self.colSep.join(
            [c + ' ' * gap for c, gap in zip(self.colnames, gaps)])]
        for r in sd:
            gaps = [m - len(c) for (m, c) in zip(colwidth, r)]
            rows.append(
                self.colSep.join([c + ' ' * d for c, d in zip(r, gaps)]))
        return self.lineSep.join(rows)


class LatexTable(Table):
    def __init__(self, data=[], colnames=[]):
        Table.__init__(self, data, colnames)
        nc = len(colnames)
        self.header = '\\begin{tabular}{%s}' % ('c' * nc)
        self.tail = '\\end{tabular}'
        self.colSep = ' & '
        self.lineSep = '\\\\ \n'

    def __str__(self):
        table_s = super(LatexTable, self).__str__()
        return '%s\n%s\n%s\n' % (self.header, table_s, self.tail)


def Table2LatexTable(table):
    return LatexTable(table.data, table.colnames)


def createSmallTable(r):
    d = []
    for k, v in r.iteritems():
        w, s, r = v
        if w == []:
            minw = None
        else:
            minw = min(w)  # returns tuple if s is list of tuples
        if s == []:
            mins = None
        else:
            mins = min(s)  # returns tuple if s is list of tuples
        d.append([k, mean(r), minw, mins])
    t = Table(d, ['exp', 'RT coef', 'WER', 'SER'])
    return t


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Parse WER amd Realtime ratio logs generated by run.sh')
    # TODO parser with commands log and exp e.g.:
    # http://pymotw.com/2/argparse/#mutually-exclusive-options

    exp = True
    if exp:
        parser.add_argument('expath', type=str, action='store')
        p = parser.parse_args()
        rt, wer, ser = getLog(p.expath)
    else:
        parser.add_argument('--werlog', action='store', type=str)
        parser.add_argument('--rtlog', action='store', type=str)
        p = parser.parse_args()
        rt, wer, ser = readLogs(p.rtlog, p.werlog)

    r = extractResults(rt, wer, ser)
    t = createSmallTable(r)
    print t
    print '=================='
    t2 = Table2LatexTable(t)
    print t2
